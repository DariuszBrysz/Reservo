# Reservo Database Schema

## 1. Custom Types

### Enums

```sql
-- Application roles
CREATE TYPE public.app_role AS ENUM ('user', 'admin');

-- Application permissions
CREATE TYPE public.app_permission AS ENUM (
  'reservations.view_all',
  'reservations.cancel_any'
);

-- Reservation status
CREATE TYPE public.reservation_status AS ENUM ('confirmed', 'canceled');
```

## 2. Tables

### 2.1 facilities

Stores information about sports facilities that can be reserved.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | bigint | PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY | Unique facility identifier |
| name | varchar(255) | NOT NULL | Name of the facility |
| created_at | timestamptz | NOT NULL, DEFAULT now() | Timestamp when facility was created |
| updated_at | timestamptz | NOT NULL, DEFAULT now() | Timestamp when facility was last updated |

```sql
CREATE TABLE public.facilities (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name varchar(255) NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.facilities IS 'Sports facilities available for reservation';
```

### 2.2 reservations

Stores all facility reservations made by users.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | bigint | PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY | Unique reservation identifier |
| facility_id | bigint | NOT NULL, FOREIGN KEY REFERENCES facilities(id) | Reference to the reserved facility |
| user_id | uuid | NOT NULL, FOREIGN KEY REFERENCES auth.users(id) ON DELETE CASCADE | Reference to the user who made the reservation |
| start_time | timestamptz | NOT NULL | Start time of the reservation (must be between 14:00 and 22:00) |
| duration | interval | NOT NULL | Duration of the reservation (must be >= 30 minutes and <= 3 hours) |
| status | reservation_status | NOT NULL, DEFAULT 'confirmed' | Current status of the reservation |
| cancellation_message | varchar(500) | NULL | Optional message provided when reservation is canceled (admin only) |
| created_at | timestamptz | NOT NULL, DEFAULT now() | Timestamp when reservation was created |
| updated_at | timestamptz | NOT NULL, DEFAULT now() | Timestamp when reservation was last updated |

**Validation (enforced via trigger):**
- Duration must be >= 30 minutes and <= 3 hours
- Reservations must be between 14:00 and 22:00
- No overlapping reservations for the same facility

```sql
CREATE TABLE public.reservations (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  facility_id bigint NOT NULL REFERENCES public.facilities(id),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  start_time timestamptz NOT NULL,
  duration interval NOT NULL,
  status public.reservation_status NOT NULL DEFAULT 'confirmed',
  cancellation_message varchar(500),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.reservations IS 'Facility reservations made by users';
COMMENT ON COLUMN public.reservations.cancellation_message IS 'Optional cancellation reason provided by administrator';
```

### 2.3 user_roles

Maps users to their application roles.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | bigint | PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY | Unique user role assignment identifier |
| user_id | uuid | NOT NULL, FOREIGN KEY REFERENCES auth.users(id) ON DELETE CASCADE | Reference to the user |
| role | app_role | NOT NULL | Role assigned to the user |
| created_at | timestamptz | NOT NULL, DEFAULT now() | Timestamp when role was assigned |

**Constraints:**
- UNIQUE constraint on (user_id, role) to prevent duplicate role assignments

```sql
CREATE TABLE public.user_roles (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role public.app_role NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (user_id, role)
);

COMMENT ON TABLE public.user_roles IS 'Application roles assigned to users';
```

### 2.4 role_permissions

Defines permissions for each application role.

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | bigint | PRIMARY KEY, GENERATED BY DEFAULT AS IDENTITY | Unique role permission identifier |
| role | app_role | NOT NULL | Role that has the permission |
| permission | app_permission | NOT NULL | Permission granted to the role |

**Constraints:**
- UNIQUE constraint on (role, permission) to prevent duplicate permission assignments

```sql
CREATE TABLE public.role_permissions (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role public.app_role NOT NULL,
  permission public.app_permission NOT NULL,
  UNIQUE (role, permission)
);

COMMENT ON TABLE public.role_permissions IS 'Permissions granted to each application role';
```

**Initial Data:**
```sql
INSERT INTO public.role_permissions (role, permission) VALUES
  ('admin', 'reservations.view_all'),
  ('admin', 'reservations.cancel_any');
```

## 3. Relationships

### 3.1 Entity Relationship Summary

```
auth.users (managed by Supabase Auth)
  ├── 1:N → reservations (ON DELETE CASCADE)
  └── 1:N → user_roles (ON DELETE CASCADE)

facilities
  └── 1:N → reservations (NO ACTION - prevents facility deletion if reservations exist)

user_roles
  └── N:1 → auth.users

reservations
  ├── N:1 → facilities
  └── N:1 → auth.users

role_permissions
  └── (no foreign keys - uses enum types)
```

### 3.2 Detailed Relationships

1. **reservations → facilities**
   - Type: Many-to-one
   - Foreign Key: `reservations.facility_id` → `facilities.id`
   - On Delete: NO ACTION (default)
   - Rationale: Prevents deletion of facilities that have reservations

2. **reservations → auth.users**
   - Type: Many-to-one
   - Foreign Key: `reservations.user_id` → `auth.users.id`
   - On Delete: CASCADE
   - Rationale: When a user is deleted, their reservations should also be removed

3. **user_roles → auth.users**
   - Type: Many-to-one
   - Foreign Key: `user_roles.user_id` → `auth.users.id`
   - On Delete: CASCADE
   - Rationale: When a user is deleted, their role assignments should also be removed

## 4. Indexes

### 4.1 Primary Indexes

Primary key indexes are automatically created for all tables:
- `facilities_pkey` on `facilities(id)`
- `reservations_pkey` on `reservations(id)`
- `user_roles_pkey` on `user_roles(id)`
- `role_permissions_pkey` on `role_permissions(id)`

### 4.2 Unique Indexes

Unique indexes are automatically created for UNIQUE constraints:
- `user_roles_user_id_role_key` on `user_roles(user_id, role)`
- `role_permissions_role_permission_key` on `role_permissions(role, permission)`

### 4.3 Foreign Key Indexes

```sql
-- Index for facility reservations lookup
CREATE INDEX idx_reservations_facility_id ON public.reservations(facility_id);

-- Index for user reservations lookup
CREATE INDEX idx_reservations_user_id ON public.reservations(user_id);

-- Index for user roles lookup
CREATE INDEX idx_user_roles_user_id ON public.user_roles(user_id);
```

### 4.4 Performance Indexes

```sql
-- Composite index for efficiently fetching facility schedules by date
CREATE INDEX idx_reservations_facility_start_time 
  ON public.reservations(facility_id, start_time) 
  WHERE status = 'confirmed';

-- Index for efficiently fetching upcoming reservations
CREATE INDEX idx_reservations_start_time 
  ON public.reservations(start_time) 
  WHERE status = 'confirmed';
```

## 5. Database Functions

### 5.1 Reservation Validation Function

This trigger function validates reservation data and prevents overlapping.

```sql
CREATE OR REPLACE FUNCTION public.validate_reservation()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = ''
AS $$
DECLARE
  v_end_time timestamptz;
  v_start_time_of_day time;
  v_end_time_of_day time;
  v_overlapping_count int;
BEGIN
  -- Calculate end time
  v_end_time := NEW.start_time + NEW.duration;
  
  -- Extract time of day for operating hours check
  v_start_time_of_day := NEW.start_time::time;
  v_end_time_of_day := v_end_time::time;
  
  -- Validate duration (must be >= 30 minutes and <= 3 hours)
  IF NEW.duration < interval '30 minutes' THEN
    RAISE EXCEPTION 'Reservation duration must be at least 30 minutes'
      USING HINT = 'Minimum duration is 30 minutes';
  END IF;
  
  IF NEW.duration > interval '3 hours' THEN
    RAISE EXCEPTION 'Reservation duration cannot exceed 3 hours'
      USING HINT = 'Maximum duration is 3 hours';
  END IF;
  
  -- Validate operating hours (14:00 - 22:00)
  IF v_start_time_of_day < '14:00:00'::time THEN
    RAISE EXCEPTION 'Reservation cannot start before 14:00'
      USING HINT = 'Operating hours are from 14:00 to 22:00';
  END IF;
  
  IF v_end_time_of_day > '22:00:00'::time THEN
    RAISE EXCEPTION 'Reservation cannot end after 22:00'
      USING HINT = 'Operating hours are from 14:00 to 22:00';
  END IF;
  
  -- Check for overlapping reservations (only for confirmed reservations)
  IF NEW.status = 'confirmed' THEN
    SELECT COUNT(*) INTO v_overlapping_count
    FROM public.reservations
    WHERE facility_id = NEW.facility_id
      AND status = 'confirmed'
      AND id != COALESCE(NEW.id, 0) -- Exclude current reservation on UPDATE
      AND (
        -- Check if time ranges overlap
        (start_time, start_time + duration) OVERLAPS (NEW.start_time, v_end_time)
      );
    
    IF v_overlapping_count > 0 THEN
      RAISE EXCEPTION 'This time slot is already reserved'
        USING HINT = 'Please choose a different time slot';
    END IF;
  END IF;
  
  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.validate_reservation IS 'Validates reservation data and prevents double-bookings with meaningful error messages';
```

### 5.2 Authorization Function

This function checks if the current user has a specific permission based on their role stored in the JWT.

```sql
CREATE OR REPLACE FUNCTION public.authorize(
  requested_permission app_permission
)
RETURNS boolean
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  bind_permissions int;
  user_role public.app_role;
BEGIN
  -- Fetch user role from JWT
  SELECT (auth.jwt() ->> 'user_role')::public.app_role INTO user_role;
  
  -- Count matching permissions for the user's role
  SELECT count(*)
  INTO bind_permissions
  FROM public.role_permissions
  WHERE role_permissions.permission = requested_permission
    AND role_permissions.role = user_role;
  
  RETURN bind_permissions > 0;
END;
$$;

COMMENT ON FUNCTION public.authorize IS 'Check if current user has the requested permission based on their role';
```

### 5.3 Custom Access Token Hook

This hook runs before a token is issued and adds the user's role to the JWT as a custom claim.

```sql
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb
LANGUAGE plpgsql
STABLE
SET search_path = ''
AS $$
DECLARE
  claims jsonb;
  user_role public.app_role;
BEGIN
  -- Fetch the user role from user_roles table
  SELECT role INTO user_role 
  FROM public.user_roles 
  WHERE user_id = (event->>'user_id')::uuid;
  
  claims := event->'claims';
  
  IF user_role IS NOT NULL THEN
    -- Set the user_role claim
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  ELSE
    -- Default to 'user' role if no role is assigned
    claims := jsonb_set(claims, '{user_role}', to_jsonb('user'::app_role));
  END IF;
  
  -- Update the 'claims' object in the original event
  event := jsonb_set(event, '{claims}', claims);
  
  RETURN event;
END;
$$;

COMMENT ON FUNCTION public.custom_access_token_hook IS 'Auth hook that adds user_role to JWT claims';

-- Grant necessary permissions for the auth hook
GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
GRANT EXECUTE ON FUNCTION public.custom_access_token_hook TO supabase_auth_admin;
REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook FROM authenticated, anon, public;

GRANT ALL ON TABLE public.user_roles TO supabase_auth_admin;
REVOKE ALL ON TABLE public.user_roles FROM authenticated, anon, public;
```

### 5.4 Policy for Auth Hook to Read User Roles

```sql
CREATE POLICY "Allow auth admin to read user roles" 
  ON public.user_roles
  AS PERMISSIVE FOR SELECT
  TO supabase_auth_admin
  USING (true);
```

### 5.5 Trigger Function for Updated At

```sql
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS trigger
LANGUAGE plpgsql
SET search_path = ''
AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

COMMENT ON FUNCTION public.handle_updated_at IS 'Automatically update updated_at timestamp';
```

### 5.6 Triggers

```sql
-- Trigger for validating reservations
CREATE TRIGGER validate_reservation_trigger
  BEFORE INSERT OR UPDATE ON public.reservations
  FOR EACH ROW
  EXECUTE FUNCTION public.validate_reservation();

-- Triggers for updating updated_at timestamp
CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.facilities
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();

CREATE TRIGGER set_updated_at
  BEFORE UPDATE ON public.reservations
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_updated_at();
```

## 6. Row Level Security (RLS) Policies

### 6.1 Enable RLS

```sql
ALTER TABLE public.facilities ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reservations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.role_permissions ENABLE ROW LEVEL SECURITY;
```

### 6.2 Facilities Policies

Facilities are readable by all authenticated users. Management of facilities is done at the database level (not through the application).

```sql
-- Allow all authenticated users to view facilities
CREATE POLICY "Authenticated users can view facilities"
  ON public.facilities
  FOR SELECT
  TO authenticated
  USING (true);
```

### 6.3 Reservations Policies

#### SELECT Policy

```sql
-- Users can view their own reservations
CREATE POLICY "Users can view their own reservations"
  ON public.reservations
  FOR SELECT
  TO authenticated
  USING (
    (SELECT auth.uid()) = user_id
  );

-- Admins can view all reservations
CREATE POLICY "Admins can view all reservations"
  ON public.reservations
  FOR SELECT
  TO authenticated
  USING (
    (SELECT authorize('reservations.view_all'))
  );
```

#### INSERT Policy

```sql
-- Users can create reservations for themselves
CREATE POLICY "Users can create their own reservations"
  ON public.reservations
  FOR INSERT
  TO authenticated
  WITH CHECK (
    (SELECT auth.uid()) = user_id
    AND status = 'confirmed'
    AND cancellation_message IS NULL
  );
```

#### UPDATE Policy

```sql
-- Users can update their own reservations if more than 12 hours before start
-- Users can only update duration; other fields are restricted
CREATE POLICY "Users can update their own reservations"
  ON public.reservations
  FOR UPDATE
  TO authenticated
  USING (
    (SELECT auth.uid()) = user_id
    AND status = 'confirmed'
    AND start_time > (now() + interval '12 hours')
  )
  WITH CHECK (
    (SELECT auth.uid()) = user_id
    AND status = 'confirmed'
    AND facility_id = (SELECT facility_id FROM public.reservations WHERE id = reservations.id)
    AND start_time = (SELECT start_time FROM public.reservations WHERE id = reservations.id)
    AND user_id = (SELECT user_id FROM public.reservations WHERE id = reservations.id)
    AND cancellation_message IS NULL
  );

-- Admins can update (cancel) any reservation and set cancellation message
CREATE POLICY "Admins can cancel any reservation"
  ON public.reservations
  FOR UPDATE
  TO authenticated
  USING (
    (SELECT authorize('reservations.cancel_any'))
  )
  WITH CHECK (
    (SELECT authorize('reservations.cancel_any'))
    AND status = 'canceled'
  );
```

#### DELETE Policy

```sql
-- Users can delete (cancel) their own reservations if more than 12 hours before start
CREATE POLICY "Users can delete their own reservations"
  ON public.reservations
  FOR DELETE
  TO authenticated
  USING (
    (SELECT auth.uid()) = user_id
    AND status = 'confirmed'
    AND start_time > (now() + interval '12 hours')
  );
```

## 7. Additional Notes and Design Decisions

### 7.1 Time Zone Handling

All time-based data is stored using the `timestamptz` (timestamp with time zone) data type. PostgreSQL stores these values in UTC and converts them based on the client's time zone setting. For the MVP, all times will be managed in a single fixed time zone at the application level.

### 7.2 Operating Hours

The facility operating hours (14:00 - 22:00) are enforced at the database level using a trigger.

### 7.3 Double-Booking Prevention

Double-booking prevention is enforced using a trigger-based validation function. The function checks for overlapping time ranges for the same facility.

### 7.4 Soft Deletes via Status

Rather than hard-deleting reservations, the system uses a status field. When a user or admin cancels a reservation, the status changes to 'canceled'. This preserves the historical record and allows administrators to track cancellations.

### 7.5 Default User Role

New users do not automatically receive a role assignment. The custom access token hook will default to the 'user' role if no role is found in the `user_roles` table. This means:
- Newly registered users have basic user permissions by default
- Administrators must be explicitly assigned the 'admin' role in the database

### 7.6 Column-Level Security for Cancellation Message

The `cancellation_message` column is designed to be:
- Writable only by administrators (enforced via RLS policies)
- Readable by the reservation owner and administrators (enforced via SELECT policies)

This is achieved through the combination of:
1. The INSERT policy preventing users from setting `cancellation_message`
2. The user UPDATE policy preventing users from modifying `cancellation_message`
3. The admin UPDATE policy allowing admins to set `cancellation_message` when canceling

### 7.7 Performance Considerations

1. **Composite Index**: The `idx_reservations_facility_start_time` index optimizes the common query pattern of fetching a facility's schedule for a specific date range.

2. **Trigger-Based Validation**: While triggers add a small overhead compared to native constraints, they provide better error messages to the application.

3. **Filtered Indexes**: Indexes include `WHERE status = 'confirmed'` to reduce index size and improve performance, since canceled reservations are not relevant for availability queries.

### 7.8 Data Integrity

1. **Foreign Key Constraints**: Ensure referential integrity between tables.

2. **Trigger Validation**: Enforce business rules (e.g., duration limits, operating hours, double-booking prevention) at the database level.

3. **UNIQUE Constraints**: Prevent duplicate role assignments and permission grants.

4. **NOT NULL Constraints**: Ensure required fields always have values.

### 7.9 Extensibility

The schema is designed to support future enhancements:

1. **RBAC System**: Additional roles and permissions can be added easily by extending the enums and updating the `role_permissions` table.

2. **Facility Attributes**: The `facilities` table can be extended with additional columns (e.g., capacity, type, amenities) without affecting existing functionality.

3. **Reservation Metadata**: Additional columns can be added to `reservations` (e.g., notes, special requests) as needed.

### 7.10 Security Model Summary

The security model follows a defense-in-depth approach:

1. **Authentication**: Handled by Supabase Auth
2. **Authorization**: Enforced via RLS policies
3. **Custom Claims**: User roles are embedded in JWTs via auth hooks
4. **Permission Checking**: The `authorize` function provides reusable permission checks
5. **Business Logic**: Time-based rules (12-hour edit window) are enforced in RLS policies

### 7.11 Migration Strategy

When implementing this schema:

1. Create custom types first (enums)
2. Create tables in order of dependencies (facilities → reservations)
3. Create RBAC tables (user_roles, role_permissions)
4. Insert initial permission data
5. Create functions (validate_reservation, authorize, custom_access_token_hook, handle_updated_at)
6. Create triggers (validate_reservation_trigger, set_updated_at)
7. Enable RLS on all tables
8. Create RLS policies
9. Create indexes
10. Configure the auth hook in Supabase dashboard

### 7.12 Testing Considerations

Key scenarios to test after migration:

1. **Double-booking prevention**: Attempt to create overlapping reservations
2. **Duration constraints**: Attempt to create reservations < 30 min or > 3 hours
3. **Operating hours validation**: Attempt to create reservations outside 14:00-22:00 hours
4. **RLS policies**: Verify users can only access their own reservations
5. **Admin permissions**: Verify admins can view and cancel any reservation
6. **12-hour rule**: Verify users cannot edit/cancel within 12 hours
7. **Auth hook**: Verify user_role appears in JWT claims
8. **Cascade deletes**: Verify reservation deletion when user is deleted