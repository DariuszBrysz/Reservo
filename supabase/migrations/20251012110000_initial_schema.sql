-- =====================================================================================
-- Migration: Initial Schema for Reservo
-- Description: Creates complete database schema for sports facility reservation system
-- Author: System
-- Date: 2025-10-12
-- 
-- This migration creates:
-- - Custom enum types for roles, permissions, and reservation status
-- - Core tables: facilities, reservations, user_roles, role_permissions
-- - Validation and utility functions
-- - Auth hook for JWT claims
-- - Row Level Security policies
-- - Performance indexes
-- 
-- Tables affected: facilities, reservations, user_roles, role_permissions
-- Special considerations: 
-- - All tables have RLS enabled
-- - Auth hook requires configuration in Supabase dashboard after migration
-- =====================================================================================

-- =====================================================================================
-- SECTION 1: Custom Types
-- =====================================================================================

-- Application roles enum
-- Defines the available roles in the application
create type public.app_role as enum ('user', 'admin');

-- Application permissions enum
-- Defines granular permissions that can be assigned to roles
create type public.app_permission as enum (
  'reservations.view_all',
  'reservations.cancel_any'
);

-- Reservation status enum
-- Tracks the lifecycle of a reservation
create type public.reservation_status as enum ('confirmed', 'canceled');

-- =====================================================================================
-- SECTION 2: Tables
-- =====================================================================================

-- Table: facilities
-- Stores information about sports facilities that can be reserved
create table public.facilities (
  id bigint generated by default as identity primary key,
  name varchar(255) not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

comment on table public.facilities is 'Sports facilities available for reservation';
comment on column public.facilities.id is 'Unique facility identifier';
comment on column public.facilities.name is 'Name of the facility';
comment on column public.facilities.created_at is 'Timestamp when facility was created';
comment on column public.facilities.updated_at is 'Timestamp when facility was last updated';

-- Table: reservations
-- Stores all facility reservations made by users
-- Validation rules (enforced via trigger):
-- - Duration must be >= 30 minutes and <= 3 hours
-- - Reservations must be between 14:00 and 22:00
-- - No overlapping reservations for the same facility
create table public.reservations (
  id bigint generated by default as identity primary key,
  facility_id bigint not null references public.facilities(id),
  user_id uuid not null references auth.users(id) on delete cascade,
  start_time timestamptz not null,
  duration interval not null,
  status public.reservation_status not null default 'confirmed',
  cancellation_message varchar(500),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

comment on table public.reservations is 'Facility reservations made by users';
comment on column public.reservations.id is 'Unique reservation identifier';
comment on column public.reservations.facility_id is 'Reference to the reserved facility';
comment on column public.reservations.user_id is 'Reference to the user who made the reservation';
comment on column public.reservations.start_time is 'Start time of the reservation (must be between 14:00 and 22:00)';
comment on column public.reservations.duration is 'Duration of the reservation (must be >= 30 minutes and <= 3 hours)';
comment on column public.reservations.status is 'Current status of the reservation';
comment on column public.reservations.cancellation_message is 'Optional cancellation reason provided by administrator';
comment on column public.reservations.created_at is 'Timestamp when reservation was created';
comment on column public.reservations.updated_at is 'Timestamp when reservation was last updated';

-- Table: user_roles
-- Maps users to their application roles
-- A user can have multiple roles (though typically just one in this MVP)
create table public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  role public.app_role not null,
  created_at timestamptz not null default now(),
  unique (user_id, role)
);

comment on table public.user_roles is 'Application roles assigned to users';
comment on column public.user_roles.id is 'Unique user role assignment identifier';
comment on column public.user_roles.user_id is 'Reference to the user';
comment on column public.user_roles.role is 'Role assigned to the user';
comment on column public.user_roles.created_at is 'Timestamp when role was assigned';

-- Table: role_permissions
-- Defines permissions for each application role
-- This enables Role-Based Access Control (RBAC)
create table public.role_permissions (
  id bigint generated by default as identity primary key,
  role public.app_role not null,
  permission public.app_permission not null,
  unique (role, permission)
);

comment on table public.role_permissions is 'Permissions granted to each application role';
comment on column public.role_permissions.id is 'Unique role permission identifier';
comment on column public.role_permissions.role is 'Role that has the permission';
comment on column public.role_permissions.permission is 'Permission granted to the role';

-- =====================================================================================
-- SECTION 3: Initial Data
-- =====================================================================================

-- Insert initial permissions for admin role
-- Admins can view all reservations and cancel any reservation
insert into public.role_permissions (role, permission) values
  ('admin', 'reservations.view_all'),
  ('admin', 'reservations.cancel_any');

-- =====================================================================================
-- SECTION 4: Functions
-- =====================================================================================

-- Function: validate_reservation
-- Purpose: Validates reservation data and prevents overlapping bookings
-- Trigger: Runs before INSERT or UPDATE on reservations table
-- Validation rules:
-- 1. Duration must be between 30 minutes and 3 hours
-- 2. Reservations must start and end between 14:00 and 22:00
-- 3. No overlapping confirmed reservations for the same facility
create or replace function public.validate_reservation()
returns trigger
language plpgsql
SET search_path = ''
as $$
declare
  v_end_time timestamptz;
  v_start_time_of_day time;
  v_end_time_of_day time;
  v_overlapping_count int;
begin
  -- Calculate end time
  v_end_time := new.start_time + new.duration;
  
  -- Extract time of day for operating hours check
  v_start_time_of_day := new.start_time::time;
  v_end_time_of_day := v_end_time::time;
  
  -- Validate duration (must be >= 30 minutes and <= 3 hours)
  if new.duration < interval '30 minutes' then
    raise exception 'Reservation duration must be at least 30 minutes'
      using hint = 'Minimum duration is 30 minutes';
  end if;
  
  if new.duration > interval '3 hours' then
    raise exception 'Reservation duration cannot exceed 3 hours'
      using hint = 'Maximum duration is 3 hours';
  end if;
  
  -- Validate operating hours (14:00 - 22:00)
  if v_start_time_of_day < '14:00:00'::time then
    raise exception 'Reservation cannot start before 14:00'
      using hint = 'Operating hours are from 14:00 to 22:00';
  end if;
  
  if v_end_time_of_day > '22:00:00'::time then
    raise exception 'Reservation cannot end after 22:00'
      using hint = 'Operating hours are from 14:00 to 22:00';
  end if;
  
  -- Check for overlapping reservations (only for confirmed reservations)
  if new.status = 'confirmed' then
    select count(*) into v_overlapping_count
    from public.reservations
    where facility_id = new.facility_id
      and status = 'confirmed'
      and id != coalesce(new.id, 0) -- exclude current reservation on update
      and (
        -- check if time ranges overlap
        (start_time, start_time + duration) overlaps (new.start_time, v_end_time)
      );
    
    if v_overlapping_count > 0 then
      raise exception 'This time slot is already reserved'
        using hint = 'Please choose a different time slot';
    end if;
  end if;
  
  return new;
end;
$$;

comment on function public.validate_reservation is 'Validates reservation data and prevents double-bookings with meaningful error messages';

-- Function: authorize
-- Purpose: Check if current user has a specific permission based on their role
-- Parameters: requested_permission - the permission to check
-- Returns: boolean - true if user has the permission, false otherwise
-- Security: SECURITY DEFINER allows function to read role_permissions table
-- Note: This function reads the user_role from JWT claims set by the auth hook
create or replace function public.authorize(
  requested_permission app_permission
)
returns boolean
language plpgsql
stable
security definer
set search_path = ''
as $$
declare
  bind_permissions int;
  user_role public.app_role;
begin
  -- fetch user role from jwt
  select (auth.jwt() ->> 'user_role')::public.app_role into user_role;
  
  -- count matching permissions for the user's role
  select count(*)
  into bind_permissions
  from public.role_permissions
  where role_permissions.permission = requested_permission
    and role_permissions.role = user_role;
  
  return bind_permissions > 0;
end;
$$;

comment on function public.authorize is 'Check if current user has the requested permission based on their role';

-- Function: custom_access_token_hook
-- Purpose: Auth hook that adds user_role to JWT claims
-- Trigger: Runs before a token is issued
-- Security: This function is called by supabase_auth_admin
-- Note: After migration, this hook must be configured in Supabase Dashboard:
--       Authentication -> Hooks -> Custom Access Token Hook
--       Set to: public.custom_access_token_hook
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
SET search_path = ''
as $$
declare
  claims jsonb;
  user_role public.app_role;
begin
  -- fetch the user role from user_roles table
  select role into user_role 
  from public.user_roles 
  where user_id = (event->>'user_id')::uuid;
  
  claims := event->'claims';
  
  if user_role is not null then
    -- set the user_role claim
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  else
    -- default to 'user' role if no role is assigned
    claims := jsonb_set(claims, '{user_role}', to_jsonb('user'::app_role));
  end if;
  
  -- update the 'claims' object in the original event
  event := jsonb_set(event, '{claims}', claims);
  
  return event;
end;
$$;

comment on function public.custom_access_token_hook is 'Auth hook that adds user_role to JWT claims';

-- Grant necessary permissions for the auth hook
-- The supabase_auth_admin role needs to execute this function
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook from authenticated, anon, public;

-- The auth hook needs to read from user_roles table
grant all on table public.user_roles to supabase_auth_admin;
revoke all on table public.user_roles from authenticated, anon, public;

-- Function: handle_updated_at
-- Purpose: Automatically update updated_at timestamp on row updates
-- Trigger: Runs before UPDATE on tables with updated_at column
create or replace function public.handle_updated_at()
returns trigger
language plpgsql
SET search_path = ''
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

comment on function public.handle_updated_at is 'Automatically update updated_at timestamp';

-- =====================================================================================
-- SECTION 5: Triggers
-- =====================================================================================

-- Trigger: validate_reservation_trigger
-- Validates reservation data before insert or update
create trigger validate_reservation_trigger
  before insert or update on public.reservations
  for each row
  execute function public.validate_reservation();

-- Trigger: set_updated_at (facilities)
-- Automatically updates updated_at timestamp on facilities table
create trigger set_updated_at
  before update on public.facilities
  for each row
  execute function public.handle_updated_at();

-- Trigger: set_updated_at (reservations)
-- Automatically updates updated_at timestamp on reservations table
create trigger set_updated_at
  before update on public.reservations
  for each row
  execute function public.handle_updated_at();

-- =====================================================================================
-- SECTION 6: Row Level Security (RLS)
-- =====================================================================================

-- Enable RLS on all tables
-- This ensures that all data access is controlled by RLS policies
alter table public.facilities enable row level security;
alter table public.reservations enable row level security;
alter table public.user_roles enable row level security;
alter table public.role_permissions enable row level security;

-- =====================================================================================
-- SECTION 6.1: Facilities Policies
-- =====================================================================================

-- Policy: Authenticated users can view facilities
-- Rationale: All logged-in users need to see available facilities to make reservations
-- Management of facilities is done at the database level (not through the application)
create policy "Authenticated users can view facilities"
  on public.facilities
  as permissive for select
  to authenticated
  using (true);

-- =====================================================================================
-- SECTION 6.2: Reservations Policies
-- =====================================================================================

-- Policy: Users can view their own reservations
-- Rationale: Users should see their own bookings
create policy "Users can view their own reservations"
  on public.reservations
  as permissive for select
  to authenticated
  using (
    (SELECT auth.uid()) = user_id
  );

-- Policy: Admins can view all reservations
-- Rationale: Administrators need visibility into all bookings for management
create policy "Admins can view all reservations"
  on public.reservations
  as permissive for select
  to authenticated
  using (
    (SELECT authorize('reservations.view_all'))
  );

-- Policy: Users can create their own reservations
-- Rationale: Users can only create reservations for themselves
-- Security: Prevents users from setting status to 'canceled' or adding cancellation_message
create policy "Users can create their own reservations"
  on public.reservations
  as permissive for insert
  to authenticated
  with check (
    (SELECT auth.uid()) = user_id
    and status = 'confirmed'
    and cancellation_message is null
  );

-- Policy: Users can update their own reservations
-- Rationale: Users can modify their bookings if more than 12 hours before start time
-- Restrictions:
-- - Can only update duration field
-- - Cannot change facility_id, start_time, user_id, status, or cancellation_message
-- - Must be at least 12 hours before the reservation starts
create policy "Users can update their own reservations"
  on public.reservations
  as permissive for update
  to authenticated
  using (
    (SELECT auth.uid()) = user_id
    and status = 'confirmed'
    and start_time > (now() + interval '12 hours')
  )
  with check (
    (SELECT auth.uid()) = user_id
    and status = 'confirmed'
    and facility_id = (select facility_id from public.reservations where id = reservations.id)
    and start_time = (select start_time from public.reservations where id = reservations.id)
    and user_id = (select user_id from public.reservations where id = reservations.id)
    and cancellation_message is null
  );

-- Policy: Admins can cancel any reservation
-- Rationale: Administrators need ability to cancel reservations and provide reason
-- Security: Admin can only update to 'canceled' status and set cancellation_message
create policy "Admins can cancel any reservation"
  on public.reservations
  as permissive for update
  to authenticated
  using (
    (SELECT authorize('reservations.cancel_any'))
  )
  with check (
    (SELECT authorize('reservations.cancel_any'))
    and status = 'canceled'
  );

-- Policy: Users can delete their own reservations
-- Rationale: Users can cancel (delete) their bookings if more than 12 hours before start
-- Note: This implements soft-delete behavior - application should update status instead
create policy "Users can delete their own reservations"
  on public.reservations
  as permissive for delete
  to authenticated
  using (
    (SELECT auth.uid()) = user_id
    and status = 'confirmed'
    and start_time > (now() + interval '12 hours')
  );

-- =====================================================================================
-- SECTION 6.3: User Roles Policies
-- =====================================================================================

-- Policy: Allow auth admin to read user roles
-- Rationale: The custom_access_token_hook needs to read user roles
-- Security: This policy is specifically for the supabase_auth_admin role
create policy "Allow auth admin to read user roles" 
  on public.user_roles
  as permissive for select
  to supabase_auth_admin
  using (true);

-- =====================================================================================
-- SECTION 7: Indexes
-- =====================================================================================

-- Foreign key indexes
-- These improve join performance and foreign key constraint checks

-- Index for looking up all reservations for a specific facility
create index idx_reservations_facility_id on public.reservations(facility_id);

-- Index for looking up all reservations for a specific user
create index idx_reservations_user_id on public.reservations(user_id);

-- Index for looking up roles for a specific user
create index idx_user_roles_user_id on public.user_roles(user_id);

-- Performance indexes
-- These optimize common query patterns

-- Composite index for efficiently fetching facility schedules by date
-- Filtered to only include confirmed reservations since canceled ones don't affect availability
create index idx_reservations_facility_start_time 
  on public.reservations(facility_id, start_time) 
  where status = 'confirmed';

-- Index for efficiently fetching upcoming reservations
-- Useful for displaying user's upcoming bookings or system-wide upcoming reservations
create index idx_reservations_start_time 
  on public.reservations(start_time) 
  where status = 'confirmed';

-- =====================================================================================
-- Migration Complete
-- =====================================================================================

-- Post-migration steps:
-- 1. Configure the custom access token hook in Supabase Dashboard:
--    Authentication -> Hooks -> Custom Access Token Hook
--    Set to: public.custom_access_token_hook
-- 2. Add initial facility data (if needed)
-- 3. Assign admin role to initial administrator user(s) in user_roles table
-- 4. Test the schema with the scenarios outlined in section 7.12 of db-plan.md

